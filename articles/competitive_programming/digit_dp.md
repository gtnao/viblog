# 桁DP（Digit Dynamic Programming）

桁DPは、数値の各桁を順番に決定していく動的計画法の一種であり、主に「ある範囲内の数値のうち、特定の条件を満たすものの個数を数える」問題に対して適用される。この手法は、数値を文字列として扱い、上位桁から順番に決定していくことで、指数的な探索空間を多項式時間で処理可能にする。

## 桁DPの基本概念

桁DPの本質は、数値を桁ごとに分解して処理することにある。例えば、$0$から$N$までの整数のうち、ある条件を満たすものの個数を数える問題を考える。素朴なアプローチでは$O(N)$の計算量が必要となるが、$N$が$10^{18}$のような巨大な値の場合、この方法は現実的ではない。桁DPを用いることで、この問題を$O(\log N)$の桁数に比例する計算量で解くことができる。

桁DPの核心的なアイデアは、数値を上位桁から順番に構築していく過程で、「現在構築中の数値が上限値以下であることが確定しているか」という情報を状態として持つことである。この状態管理により、効率的な計算が可能となる。

```mermaid
graph TD
    A["初期状態"]
    B["1桁目を決定"]
    C["2桁目を決定"]
    D["最終桁まで決定"]
    
    A --> B
    B --> C
    C --> D
    
    B --> E["tight状態"]
    B --> F["not tight状態"]
    
    E --> G["制約あり遷移"]
    F --> H["自由遷移"]
```

## 状態の定義と遷移

桁DPにおける状態は、一般的に以下の要素から構成される：

1. **現在処理している桁の位置**（$pos$）：上位桁から何桁目を処理しているか
2. **tight制約**（$tight$）：これまでに構築した部分が上限値と一致しているか
3. **問題固有の状態**：例えば、これまでに出現した数字の集合、和、積など

tight制約は桁DPの最も重要な概念の一つである。$tight = true$の場合、次に選択できる数字は上限値の対応する桁以下に制限される。一方、$tight = false$の場合は、$0$から$9$までの任意の数字を選択できる。

状態遷移の一般的な形式は以下のように表現される：

$$dp[pos][tight][state] = \sum_{d=0}^{limit} dp[pos+1][tight \land (d = limit)][next\_state]$$

ここで、$limit$は$tight$が$true$の場合は上限値の$pos$桁目の数字、$false$の場合は$9$となる。

## Leading Zeroの扱い

多くの桁DP問題では、leading zero（先頭の0）の扱いが重要となる。例えば、「各桁の数字がすべて異なる数の個数を数える」問題を考える。この場合、$007$と$7$を区別する必要がある。

leading zeroを適切に扱うため、追加の状態変数$started$を導入する。この変数は、「意味のある数字が既に始まっているか」を表す。

```mermaid
graph LR
    A["started=false"] --> B["0を選択"]
    A --> C["1-9を選択"]
    B --> D["started=false維持"]
    C --> E["started=true遷移"]
    E --> F["以降はstarted=true"]
```

leading zeroの処理により、状態空間は以下のように拡張される：

$$dp[pos][tight][started][state]$$

遷移においては、$started = false$かつ選択した数字が$0$の場合、次の状態でも$started = false$を維持する。それ以外の場合は$started = true$となる。

## 実装の詳細

桁DPの実装では、メモ化再帰を用いることが一般的である。以下に、基本的な実装パターンを示す：

```cpp
long long solve(int pos, bool tight, bool started, State state) {
    // Base case: all digits processed
    if (pos == n) {
        return checkCondition(state) ? 1 : 0;
    }
    
    // Memoization check
    if (!tight && started && memo[pos][state] != -1) {
        return memo[pos][state];
    }
    
    int limit = tight ? digits[pos] : 9;
    long long result = 0;
    
    for (int d = 0; d <= limit; d++) {
        if (!started && d == 0) {
            // Leading zero case
            result += solve(pos + 1, tight && (d == limit), false, state);
        } else {
            // Normal transition
            State newState = updateState(state, d);
            result += solve(pos + 1, tight && (d == limit), true, newState);
        }
    }
    
    if (!tight && started) {
        memo[pos][state] = result;
    }
    
    return result;
}
```

メモ化において重要な点は、$tight = true$の場合はメモ化しないことである。これは、tight制約下での値は入力に依存するため、再利用できないからである。

## 計算量分析

桁DPの計算量は、状態数と各状態での遷移数の積で決まる。一般的な桁DP問題では：

- 桁数：$O(\log N)$
- tight状態：$O(1)$（booleanのため）
- 問題固有の状態：$O(S)$（問題依存）
- 各状態での遷移：$O(10)$（0-9の数字）

したがって、全体の計算量は$O(10 \cdot \log N \cdot S)$となる。$S$が多項式オーダーであれば、全体として多項式時間で解くことができる。

メモリ使用量については、tight制約がtrueの場合はメモ化しないため、実際に保存する状態数は$O(\log N \cdot S)$となる。

## 高度な最適化技法

桁DPの実装において、いくつかの最適化技法が存在する：

### 1. 状態圧縮

問題固有の状態が集合を表す場合、ビットマスクを用いて状態を圧縮できる。例えば、「使用した数字の集合」を管理する場合、10ビットのビットマスクで表現可能である。

### 2. 前計算による高速化

頻繁に使用する値や、状態遷移で必要な計算結果を前計算しておくことで、実行時間を短縮できる。

### 3. 不要な状態の削減

問題の性質を分析し、到達不可能な状態や、答えに寄与しない状態を事前に除外することで、探索空間を削減できる。

## 典型的な問題パターン

桁DPが適用される典型的な問題パターンを分析すると、以下のような分類が可能である：

### 1. 条件を満たす数の個数計算

最も基本的なパターンであり、「$L$以上$R$以下の整数のうち、条件$C$を満たすものの個数」を求める問題である。この場合、$[0, R]$と$[0, L-1]$の範囲でそれぞれ桁DPを実行し、その差を取る。

### 2. 和・積の計算

条件を満たす数の和や積を求める問題では、状態に「現在までの和」や「積の剰余」を含める必要がある。

### 3. 最大値・最小値問題

条件を満たす数の中での最大値や最小値を求める場合、貪欲法的なアプローチと組み合わせることが多い。

## 実装上の注意点

桁DPの実装において、よくある誤りとその対策を述べる：

### 1. オーバーフロー対策

個数や和を計算する際、結果が64ビット整数の範囲を超える可能性がある。適切にmodulo演算を適用するか、多倍長整数を使用する必要がある。

### 2. 境界条件の処理

$L = 0$の場合や、leading zeroを含む場合の処理は特に注意が必要である。edge caseを丁寧に処理することが重要である。

### 3. メモ化の初期化

メモ化配列の初期化を忘れると、誤った結果を返す可能性がある。テストケースごとに適切に初期化することが必要である。

## 変種と拡張

桁DPの基本的な枠組みは、様々な方向に拡張可能である：

### 1. 多次元への拡張

2つ以上の数値を同時に扱う問題では、それぞれの数値に対してtight制約を管理する必要がある。状態空間は指数的に増大するが、基本的な考え方は同じである。

### 2. 異なる基数への適用

10進数以外の基数（2進数、16進数など）に対しても、桁DPは同様に適用できる。遷移で考慮する数字の範囲を変更するだけで対応可能である。

### 3. 文字列への応用

数値だけでなく、辞書順で特定の範囲にある文字列の個数を数える問題にも、桁DPの考え方を適用できる。

## 実践的な設計指針

桁DPを用いた問題解決において、以下の設計指針が有用である：

### 1. 状態設計の原則

状態は必要最小限に留めることが重要である。不必要に詳細な情報を状態に含めると、計算量とメモリ使用量が増大する。問題の本質を見極め、真に必要な情報のみを状態として管理する。

### 2. デバッグ戦略

桁DPのデバッグは複雑になりがちである。小さな入力での手計算結果と照合する、各状態での遷移を可視化する、といった手法が有効である。

### 3. テストケースの設計

境界値（$L = 0$、$L = R$、1桁の数など）、典型的なケース、大規模なケースを網羅的にテストすることが重要である。

桁DPは、一見複雑に見える数値に関する計数問題を、体系的かつ効率的に解決する強力な手法である。その本質は、数値を桁ごとに分解し、上位桁から順番に決定していく過程で適切な状態管理を行うことにある。tight制約とleading zeroの扱いを正しく理解し、問題に応じた状態設計を行うことで、幅広い問題に適用可能である。実装においては、メモ化による効率化と、境界条件の丁寧な処理が成功の鍵となる。
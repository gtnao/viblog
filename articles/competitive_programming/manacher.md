# Manacher法：線形時間での回文検出アルゴリズム

回文（palindrome）は文字列処理において頻繁に現れる重要な構造である。前後から読んでも同じになる文字列という単純な定義にもかかわらず、効率的な検出は自明ではない。特に、文字列のすべての位置における最長回文の長さを求める問題は、素朴なアプローチでは各位置から両側に拡張していく必要があり、最悪計算量はO(n²)となる。Manacher法は、この問題を驚くべきことにO(n)の線形時間で解決する。

本稿では、Manacher法の背後にある巧妙なアイデアと、その実装における詳細を解説する。このアルゴリズムは1975年にGlenn K. Manacherによって発表された¹が、その美しさと実用性から現在でも競技プログラミングや文字列処理の分野で広く使用されている。

## 回文検出の基本的アプローチとその限界

文字列中の回文を検出する最も直感的な方法は、各位置を中心として左右に文字を比較していく中心拡張法である。例えば、文字列"abacabad"において位置3（0-indexed）の'c'を中心とする場合、左右に1文字ずつ拡張して'aca'が回文であることを確認し、さらに拡張して'bacab'が回文であることを確認する、という手順を踏む。

```mermaid
graph TD
    A["文字列: abacabad"]
    B["位置3を中心に拡張"]
    C["c → aca → bacab"]
    D["最長回文半径: 2"]
    
    A --> B
    B --> C
    C --> D
```

この方法の問題点は、各位置で独立に拡張を行うため、同じ文字の比較を何度も繰り返すことにある。最悪の場合、"aaaa...a"のようなすべて同じ文字からなる文字列では、各位置でn/2回程度の比較が必要となり、全体でO(n²)の計算量となる。

さらに、偶数長回文と奇数長回文を別々に扱う必要があるという実装上の複雑さもある。"abba"のような偶数長回文は中心が文字と文字の間にあるため、単純な中心拡張法では扱いにくい。

## Manacher法の核心：対称性の活用

Manacher法の革新的なアイデアは、すでに計算した回文の情報を利用して、後続の計算を高速化することにある。具体的には、ある大きな回文の内部では、その中心に関して対称な位置の回文情報が部分的に一致するという性質を利用する。

```mermaid
graph LR
    subgraph "大きな回文内の対称性"
        A["左側の既知の回文"]
        B["中心"]
        C["右側の未知の回文"]
        
        A -.->|"対称性"| C
        B -->|"軸"| A
        B -->|"軸"| C
    end
```

この対称性により、右側の位置における回文半径の初期値を、対称な左側の位置の情報から推定できる。ただし、この推定値は必ずしも正確ではなく、大きな回文の境界を超える場合は追加の拡張が必要となる。

## アルゴリズムの詳細な動作

Manacher法を実装する際の第一歩は、偶数長回文と奇数長回文を統一的に扱うための前処理である。元の文字列の各文字の間に特殊な文字（通常は'#'などの元の文字列に含まれない文字）を挿入することで、すべての回文を奇数長として扱えるようになる。

例えば、"abba"は"#a#b#b#a#"に変換される。この変換により、元の文字列の偶数長回文"abba"は、変換後の文字列では中心が'#'である奇数長回文"#a#b#b#a#"として検出される。

```python
def preprocess(s):
    # Insert special character between all characters
    return '#' + '#'.join(s) + '#'
```

次に、各位置における最長回文半径を格納する配列P[]を用意する。P[i]は位置iを中心とする最長回文の半径（中心を含まない片側の長さ）を表す。また、現在までに発見された回文のうち、最も右端が遠い回文の中心Cと右端Rを記録する。

アルゴリズムの主要部分は以下のように動作する：

```mermaid
flowchart TD
    A["位置iの処理開始"]
    B{"i < R ?"}
    C["対称位置j = 2*C - i"]
    D["P[i] = min(P[j], R-i)"]
    E["P[i] = 0"]
    F["中心拡張法で回文を拡張"]
    G{"拡張後の右端 > R ?"}
    H["C = i, R = i + P[i]"]
    I["次の位置へ"]
    
    A --> B
    B -->|Yes| C
    B -->|No| E
    C --> D
    D --> F
    E --> F
    F --> G
    G -->|Yes| H
    G -->|No| I
    H --> I
```

重要なのは、位置iがすでに発見された大きな回文（中心C、右端R）の内部にある場合、対称位置j = 2*C - iの情報を利用できる点である。ただし、この情報をそのまま使えるのは、対称位置の回文が大きな回文の境界内に収まっている場合のみである。そのため、P[i]の初期値はmin(P[j], R-i)となる。

## 実装の詳細と最適化

Manacher法の完全な実装は以下のようになる：

```python
def manacher(s):
    # Preprocess string
    t = '#' + '#'.join(s) + '#'
    n = len(t)
    p = [0] * n
    c = r = 0
    
    for i in range(n):
        # Use symmetry if possible
        if i < r:
            j = 2 * c - i  # Mirror position
            p[i] = min(p[j], r - i)
        
        # Try to expand palindrome centered at i
        try:
            while t[i + p[i] + 1] == t[i - p[i] - 1]:
                p[i] += 1
        except IndexError:
            pass
        
        # Update center and right boundary if needed
        if i + p[i] > r:
            c = i
            r = i + p[i]
    
    return p
```

この実装では境界チェックをtry-exceptで行っているが、より効率的な実装では文字列の両端に別の特殊文字（例えば'^'と'$'）を追加することで、境界チェックを不要にできる。

```python
def manacher_optimized(s):
    t = '^#' + '#'.join(s) + '#$'
    n = len(t)
    p = [0] * n
    c = r = 0
    
    for i in range(1, n - 1):
        if i < r:
            p[i] = min(p[2 * c - i], r - i)
        
        while t[i + p[i] + 1] == t[i - p[i] - 1]:
            p[i] += 1
        
        if i + p[i] > r:
            c, r = i, i + p[i]
    
    return p
```

## 計算量の解析

Manacher法がO(n)で動作することの証明は、各文字が比較される回数を注意深く数えることで示される。アルゴリズムの各ステップは以下の２つの部分に分けられる：

1. 対称性を利用した初期値の設定（O(1)）
2. 中心拡張法による追加の拡張

重要な観察は、中心拡張法で新たに比較される文字は、必ず現在の右端Rより右側にあるということである。そして、一度比較された位置は二度と比較されない（Rは単調増加するため）。したがって、全体の比較回数は高々2n回となり、アルゴリズム全体の計算量はO(n)となる。

```mermaid
graph TD
    subgraph "計算量の証明"
        A["各位置での処理"]
        B["対称性利用: O(1)"]
        C["新規拡張: Rより右のみ"]
        D["Rは単調増加"]
        E["各文字の比較は最大1回"]
        F["全体: O(n)"]
        
        A --> B
        A --> C
        C --> D
        D --> E
        E --> F
    end
```

## 元の文字列における回文の抽出

前処理により拡張された文字列での結果から、元の文字列における回文情報を抽出する必要がある。拡張文字列の位置iにおける回文半径P[i]は、元の文字列における回文の長さと以下の関係がある：

- 拡張文字列の位置iが元の文字に対応する場合（i%2 == 1）：元の文字列での回文長は奇数でP[i]
- 拡張文字列の位置iが'#'に対応する場合（i%2 == 0）：元の文字列での回文長は偶数でP[i]

元の文字列における位置への変換は、i/2で行える。

## 実践的な応用例

Manacher法は単に最長回文を求めるだけでなく、様々な問題に応用できる。例えば、文字列中のすべての回文部分文字列を効率的に列挙する問題や、回文を含む動的計画法の問題などで威力を発揮する。

競技プログラミングでは、以下のような問題でManacher法が有効である：

1. 文字列を回文に分割する最小分割数を求める問題
2. 各位置を終点とする最長回文接頭辞を求める問題
3. 回文の個数を数える問題

これらの問題では、Manacher法で得られた各位置の最長回文半径の情報を前処理として使用し、その後の計算を効率化する。

## 実装上の注意点とバリエーション

実装において注意すべき点として、文字列の前処理で使用する特殊文字の選択がある。元の文字列に含まれない文字を選ぶ必要があり、実装によってはASCIIコードの範囲外の文字を使用することもある。

また、メモリ使用量を削減したい場合は、拡張文字列を実際に作成せず、インデックスの変換で対応する実装も可能である：

```python
def manacher_memory_efficient(s):
    n = len(s)
    # Array for original string positions only
    p_odd = [0] * n  # Odd length palindromes
    p_even = [0] * n  # Even length palindromes
    
    # Process odd length palindromes
    c = r = 0
    for i in range(n):
        if i < r:
            p_odd[i] = min(p_odd[2 * c - i], r - i)
        
        while (i - p_odd[i] - 1 >= 0 and 
               i + p_odd[i] + 1 < n and 
               s[i - p_odd[i] - 1] == s[i + p_odd[i] + 1]):
            p_odd[i] += 1
        
        if i + p_odd[i] > r:
            c, r = i, i + p_odd[i]
    
    # Similar process for even length palindromes
    # ...
    
    return p_odd, p_even
```

## アルゴリズムの一般化と関連手法

Manacher法の基本的なアイデアは、他の文字列アルゴリズムにも応用されている。例えば、Z-algorithmも似たような対称性の利用により線形時間を達成している。両者の違いは、Manacher法が中心からの対称性を扱うのに対し、Z-algorithmは先頭からの一致を扱う点にある。

また、Manacher法は任意の文字列に対して動作するが、特定の性質を持つ文字列（例えば、文字種が少ない場合）では、より特化した効率的なアルゴリズムが存在することもある。

## パフォーマンスの実測と最適化

実際のシステムでManacher法を使用する際は、キャッシュ効率も考慮する必要がある。前処理で文字列を2倍以上に拡張するため、元の文字列が大きい場合はメモリアクセスのパターンが性能に影響する。

現代的なCPUアーキテクチャでは、連続的なメモリアクセスが重要であり、Manacher法は基本的に左から右への線形スキャンであるため、この点では有利である。ただし、対称位置へのランダムアクセスが発生する部分では、キャッシュミスが起こる可能性がある。

¹ Manacher, Glenn (1975). "A New Linear-Time 'On-Line' Algorithm for Finding the Smallest Initial Palindrome of a String". Journal of the ACM. 22 (3): 346–351.
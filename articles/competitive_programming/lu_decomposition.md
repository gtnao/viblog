# LU分解

線形代数において、LU分解は行列を下三角行列（Lower triangular matrix）と上三角行列（Upper triangular matrix）の積に分解する手法である。この分解は連立一次方程式の解法、逆行列の計算、行列式の計算など、数値線形代数の基礎となる重要な技術であり、競技プログラミングにおいても行列演算を効率的に実行するための強力な道具となる。

## LU分解の数学的定義

$n \times n$の正方行列$A$に対して、下三角行列$L$と上三角行列$U$が存在し、$A = LU$と分解できるとき、これをLU分解と呼ぶ。ここで、下三角行列$L$は対角成分より上の要素がすべて0であり、上三角行列$U$は対角成分より下の要素がすべて0である行列を指す。

```mermaid
graph TD
    A["行列 A"]
    L["下三角行列 L"]
    U["上三角行列 U"]
    
    A --> |"分解"| L
    A --> |"分解"| U
    L --> |"積 LU"| A
    U --> |"積 LU"| A
    
    subgraph "下三角行列の構造"
        L1["l11  0   0"]
        L2["l21 l22  0"]
        L3["l31 l32 l33"]
    end
    
    subgraph "上三角行列の構造"
        U1["u11 u12 u13"]
        U2["0  u22 u23"]
        U3["0   0  u33"]
    end
```

LU分解が存在するための必要十分条件は、行列$A$のすべての主小行列式（leading principal minors）が非零であることである[^1]。しかし、実際の数値計算では、この条件が満たされない場合でも、行の交換を伴うLU分解（部分ピボット選択付きLU分解）を用いることで、ほぼすべての非特異行列に対して分解を実行できる。

## Doolittleアルゴリズム

LU分解を計算する最も基本的なアルゴリズムはDoolittleアルゴリズムである。このアルゴリズムでは、$L$の対角成分を1に固定し（$l_{ii} = 1$）、ガウスの消去法を行列の形で記録していく。

アルゴリズムの基本的な考え方は、行列$A$に対してガウスの消去法を適用する際の操作を、下三角行列$L$に記録することである。具体的には、$A$の$(i,j)$要素を消去するために使用した乗数を$L$の$(i,j)$要素として保存する。

```mermaid
flowchart TD
    Start["開始: 行列A"]
    Init["L = I (単位行列), U = A のコピー"]
    Loop1["k = 1 to n-1"]
    Loop2["i = k+1 to n"]
    CalcMult["乗数 m_ik = u_ik / u_kk"]
    StoreMult["L_ik = m_ik"]
    UpdateRow["行i から m_ik × 行k を引く"]
    CheckPivot{"u_kk = 0?"}
    Error["ピボットが0: 分解不可能"]
    Success["分解完了: A = LU"]
    
    Start --> Init
    Init --> Loop1
    Loop1 --> Loop2
    Loop2 --> CheckPivot
    CheckPivot -->|Yes| Error
    CheckPivot -->|No| CalcMult
    CalcMult --> StoreMult
    StoreMult --> UpdateRow
    UpdateRow --> Loop2
    Loop2 -->|全てのi処理済| Loop1
    Loop1 -->|全てのk処理済| Success
```

具体的な計算手順を$3 \times 3$行列で示すと、元の行列$A$から始めて、各ステップで行基本変形を適用していく：

$$A = \begin{pmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{pmatrix}$$

第1ステップでは、第1列の第2行以下を0にする。このとき、$m_{21} = a_{21}/a_{11}$、$m_{31} = a_{31}/a_{11}$を乗数として使用し、これらを$L$の対応する位置に記録する。

## 部分ピボット選択

数値計算において、LU分解の安定性は極めて重要である。ピボット（対角要素）が小さい値になると、丸め誤差が増幅され、計算結果の精度が著しく低下する。この問題を回避するため、部分ピボット選択（partial pivoting）を導入する。

部分ピボット選択では、各ステップで現在の列の絶対値最大の要素を持つ行と交換してから消去を行う。これにより、分解は$PA = LU$の形になり、$P$は置換行列（permutation matrix）となる。

```mermaid
graph LR
    subgraph "ピボット選択なし"
        A1["小さなピボット"]
        B1["大きな乗数"]
        C1["誤差の増幅"]
        A1 --> B1
        B1 --> C1
    end
    
    subgraph "部分ピボット選択あり"
        A2["最大要素をピボットに"]
        B2["乗数 ≤ 1"]
        C2["誤差の抑制"]
        A2 --> B2
        B2 --> C2
    end
```

部分ピボット選択の重要性を示す典型的な例として、以下の行列を考える：

$$A = \begin{pmatrix} \epsilon & 1 \\ 1 & 1 \end{pmatrix}$$

ここで$\epsilon$は非常に小さな正の数である。ピボット選択なしでLU分解を行うと、$L$の$(2,1)$要素は$1/\epsilon$という巨大な値になり、数値的不安定性を引き起こす。一方、行を交換してから分解すれば、すべての要素が適切な大きさに収まる。

## 計算量と数値的性質

LU分解の計算量は$O(n^3)$である。より具体的には、$n \times n$行列に対して約$\frac{2n^3}{3}$回の浮動小数点演算が必要となる[^2]。これはガウスの消去法と同じ計算量であるが、LU分解の利点は、一度分解を計算すれば、異なる右辺ベクトルに対する連立方程式を$O(n^2)$で解けることにある。

数値安定性の観点から、部分ピボット選択付きLU分解の成長因子（growth factor）は最悪の場合$2^{n-1}$となることが知られている。しかし、実際の応用では、このような極端な成長はほとんど観測されず、通常は$O(n^{1/2})$から$O(n^{2/3})$程度に収まる[^3]。

## 前進代入と後退代入

LU分解の主要な応用は連立一次方程式$Ax = b$の解法である。$A = LU$と分解できれば、問題は以下の2つの三角連立方程式に帰着される：

1. $Ly = b$を前進代入（forward substitution）で解く
2. $Ux = y$を後退代入（backward substitution）で解く

前進代入では、$L$が下三角行列であることを利用して、上から順に未知数を求めていく：

$$y_i = b_i - \sum_{j=1}^{i-1} l_{ij}y_j$$

同様に、後退代入では下から順に求める：

$$x_i = \frac{1}{u_{ii}}\left(y_i - \sum_{j=i+1}^{n} u_{ij}x_j\right)$$

これらの代入操作はそれぞれ$O(n^2)$の計算量で実行できる。

## 競技プログラミングにおける実装

競技プログラミングでは、LU分解は主に以下の場面で活用される：

1. **連立一次方程式の高速解法**: 同じ係数行列に対して複数の右辺ベクトルを処理する場合
2. **行列式の計算**: $\det(A) = \det(L)\det(U) = \prod_{i=1}^{n} u_{ii}$（置換の符号を考慮）
3. **逆行列の計算**: 各単位ベクトルを右辺として解くことで逆行列の列を求める

実装上の注意点として、浮動小数点演算の誤差を考慮する必要がある。ピボットがゼロかどうかの判定には、厳密な比較ではなく、適切な許容誤差（通常は$10^{-9}$程度）を設定する。

```cpp
const double EPS = 1e-9;

bool LUDecomposition(vector<vector<double>>& A, vector<int>& perm) {
    int n = A.size();
    perm.resize(n);
    iota(perm.begin(), perm.end(), 0);
    
    for (int k = 0; k < n; k++) {
        // Find pivot
        int pivot = k;
        for (int i = k + 1; i < n; i++) {
            if (abs(A[i][k]) > abs(A[pivot][k])) {
                pivot = i;
            }
        }
        
        if (abs(A[pivot][k]) < EPS) return false;
        
        // Swap rows
        if (pivot != k) {
            swap(A[k], A[pivot]);
            swap(perm[k], perm[pivot]);
        }
        
        // Elimination
        for (int i = k + 1; i < n; i++) {
            A[i][k] /= A[k][k];
            for (int j = k + 1; j < n; j++) {
                A[i][j] -= A[i][k] * A[k][j];
            }
        }
    }
    return true;
}
```

## ブロックLU分解

大規模行列に対しては、ブロックLU分解が有効である。行列を適切なサイズのブロックに分割し、各ブロックを小行列として扱うことで、キャッシュ効率を向上させ、並列化も容易になる。

$$A = \begin{pmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \end{pmatrix} = \begin{pmatrix} L_{11} & 0 \\ L_{21} & L_{22} \end{pmatrix} \begin{pmatrix} U_{11} & U_{12} \\ 0 & U_{22} \end{pmatrix}$$

ブロック分解では、まず$A_{11} = L_{11}U_{11}$を通常のLU分解で求め、次に$L_{21} = A_{21}U_{11}^{-1}$、$U_{12} = L_{11}^{-1}A_{12}$を計算し、最後にSchur補行列$S = A_{22} - L_{21}U_{12}$を$L_{22}U_{22}$に分解する。

## 特殊な構造を持つ行列への応用

実際の問題では、係数行列が特殊な構造を持つことが多い。例えば、三重対角行列（tridiagonal matrix）の場合、Thomas法と呼ばれる$O(n)$のアルゴリズムが存在する。帯行列（band matrix）の場合も、帯幅を$k$とすると$O(nk^2)$で分解できる。

対称正定値行列に対しては、Cholesky分解という特殊なLU分解が存在する。これは$A = LL^T$の形に分解するもので、計算量と記憶容量が通常のLU分解の約半分で済む。

## 数値的安定性の詳細

LU分解の数値的振る舞いを理解するには、条件数（condition number）の概念が重要である。行列$A$の条件数$\kappa(A) = \|A\|\|A^{-1}\|$は、入力の相対誤差が出力の相対誤差にどの程度増幅されるかを示す指標である。

部分ピボット選択は、分解過程での誤差の増大を抑制するが、元の行列の条件数自体は改善しない。条件数が大きい行列（悪条件行列）に対しては、どのような数値解法を用いても精度の良い解を得ることは困難である。

完全ピボット選択（complete pivoting）では、行と列の両方を交換して最大要素をピボットとする。これにより数値安定性はさらに向上するが、計算量が$O(n^3)$から$O(n^3)$のままでも定数倍が大きくなるため、実用上は部分ピボット選択で十分なことが多い。

## 実装における最適化技法

競技プログラミングでの実装では、以下の最適化が有効である：

1. **インプレース計算**: $L$と$U$を同じ配列に格納し、メモリ使用量を削減
2. **ループ展開**: 内側のループを部分的に展開し、キャッシュ効率を向上
3. **SIMD命令の活用**: 複数の演算を並列実行（コンパイラの自動ベクトル化に依存）

また、整数演算で厳密な解を求める場合は、分数演算を用いるか、十分大きな素数で剰余を取るモジュラー演算を使用する。後者の場合、中国剰余定理を用いて複数の素数での結果から元の解を復元する。

## 理論的背景と拡張

LU分解は、より一般的なQR分解やSVD（特異値分解）の特殊ケースとして理解できる。QR分解では直交行列$Q$と上三角行列$R$に分解し、数値的により安定だが計算量は約2倍になる。

また、LU分解はガウスの消去法の行列表現であり、行基本変形を行列の積として表現したものと解釈できる。この観点から、LU分解は線形写像の分解として、より抽象的な数学的構造を持つ。

不完全LU分解（ILU: Incomplete LU decomposition）は、疎行列に対する前処理手法として重要である。分解の過程で小さな要素を0とみなすことで、疎性を保ちながら近似的な分解を得る。これは反復法の収束を加速する前処理行列として広く使用される。

[^1]: Golub, G. H., & Van Loan, C. F. (2013). Matrix computations (4th ed.). Johns Hopkins University Press.

[^2]: Trefethen, L. N., & Bau, D. (1997). Numerical linear algebra. SIAM.

[^3]: Higham, N. J. (2002). Accuracy and stability of numerical algorithms (2nd ed.). SIAM.